### Java线程
主要快速复习Java多线程基础知识, 本小结主要包含如下内容
1. 何为线程: 单线程、多线程、Thread类、run方法、start方法
2. 启动线程: Thread类、Runnable接口
3. 线程暂停: sleep方法
4. 线程互斥: synchronized方法、synchronized语句、锁
5. 线程协作: wait方法、notify方法、notifyAll方法


#### 何为线程
***明为跟踪处理流程, 实则跟踪线程***

##### 单线程
当我们在阅读程序, 我们总是按照程序的处理顺序阅读, 无论中间是调用了某个方法还是执行了for循环亦或者其它复杂的业务流程, 程序调用可以曲折蜿蜒但是
我们阅读(又或是执行)的顺序依旧是一条直线不会出现另外一条岔道, 对于这样的程序, 我们可以称之为***单线程程序***

单线程程序永远只有一处再执行, 我们可以非常快速的回答对方, "瞧, 程序已经运行到这了"

单线程程序非常简单, 甚至于我们编写一个Hello, World程序都是一个单线程程序, 虽然程序主体只有一个主线程(main thread), 但实际上Java还会在后台
启动GC(垃圾回收), GUI等相关线程, 所以严格来说运行任何一个程序都不仅仅只有一个线程在运行, 只不过 我们没有感知罢了。

##### 多线程
由多个线程组成的程序可以称为***多线程程序***, 我们在阅读(又或是)多个线程执行时, 我们在回答对方时需要知道线程1运行到这了, 线程2运行到那了, 如果有更多的线程
在运行, 我们需要指出更多的运行情况, 此时程序就不仅仅只是一条线走到底, 而是会出现岔道。

典型的多线程程序可以有下面一些参考:

1. GUI程序, 用户使用文本工具编辑较大的文件时, 执行了查找操作, 当文本工具执行查找时, 屏幕上可以显示"停止查找"按钮, 用户可以随时停止查找。此时可以使用多线程。

   (1) 执行查找
   (2) 显示按钮, 停止查找

两个操作分别使用不同的线程执行, (1)的操作线程专门执行查找, 而(2)的操作线程专门执行GUI操作


2. 耗时的I/O操作, 文件与网络I/O处理都非常耗时。如果在I/O处理期间, 程序几乎无法执行其它计算, 性能因此会下降。这种情况也可以使用多线程来处理。
   可以把I/O处理的线程和其它计算线程分开, 那么在I/O阻塞期间, 程序还可以执行其它计算

##### Thread类start与run方法
任何一个程序都是通过主线程启动, 然后通过主线程启动一个新的线程, 我们可以使用Thread类来启动一个新线程。不过Thread类中有一个run方法是需要我们重写的
新线程启动后会自动调用run方法, 当run方法执行结束时, 线程也会终止。

***我们通过start方法来启动一个线程, 而不是调用run方法, 当然run方法也是可以调用的, 只不过调用它并不会启动新的线程***
start方法主要做了两件事:
1. 启动新线程
2. 调用run方法

```java
public class Main {
   public static void main(String[] args) {
      Thread t = new MyThread();
      // 主线程启动一个新线程
      t.start();
      for (int i = 0; i < 100; i++) {
         //...
      }
   }
}
```

通过这个例子, 我们启动一个新的线程, 可以是循环输出也可以是其它计算操作, 由于程序是并发执行的, 所以结果或许是交织在一起输出, 计算可能会出错。对于这些问题
我们会在后面继续介绍与学习。

#### 启动线程
启动线程的方式有两种:
1. 继承Thread类
2. 实现Runnable接口


##### 通过Thread启动线程
```java

public class Main2 {
    public static void main(String[] args) {
        PrintThread t1 = new PrintThread();
        PrintThread t2 = new PrintThread("H1");
        // 只有调用start方法才算是启动一个线程
        t2.start();
        t1.setMessage("H@");
//        t1.start();
    }
}
```
上面这个例子通过继承Thread类实现动态输出传入的字符串内容, 我们创建两个线程对象实例, 并调用其中一个对象实例的start方法, 程序最终只会输出"H1"
因为***创建对象(PrintThread)实例和启动对象实例线程***是两个不同的处理。也就是说即使创建了实例, 但是如果不去调用执行start方法, 线程依旧不会被启动。

有一个点需要注意的是: PrintThread实例和线程不是同一个东西。即使创建了PrintThread实例, 线程也不会启动, 而且就算线程终止了, PrintThread实例也不会立即消失。

主线程在main方法中启动两个线程, 随后main方法结束, 主线程也随之终止。但是整个程序并不会终止, 因为启动的线程在执行完成之前是不会终止的。
直到所有的线程都终止后, 程序才会终止。也就是说, 当我们启动的线程结束, 程序才会终止。

##### 通过Runnable启动线程

```java
public class Printer implements Runnable {
   public void run() { /*...*/ }
}
public class Main3 {
   public static void main(String[] args) {
      Printer p = new Printer("msg");
      // 使用Thread包装后启动
      Thread t1 = new Thread(p);
      t1.start();
   }
}
```

我们只需要实现Runnable接口并实现run方法即可, 但是实现Runnable接口并没有继承Thread类的start方法只有一个run方法, 这是无法启动一个线程的, 
所有我么还需要创建Thread类并将实现Runnable接口实例对象传入, 然后再调用start方法, 这就是利用Runnable接口实现线程启动的方法。

***不管是继承Thread类还是实现Runnable接口, 想要启动一个新线程最终都是使用Thread类的start方法***

#### 线程暂停
我们可以通过Thread类中的sleep方法让线程进行休眠, sleep方法是一个静态方法。sleep方法方法的调用放在了try...catch中, 这是因为sleep方法可能会抛出
InterruptedException异常。InterruptedException异常能够取消线程的处理(后面会详解)

sleep实际生产中频率不会使用太多, 毕竟没有任何人希望等待很长时间, 但也有一些场景可以使用, 比如游戏结束给定一个时间不继续就退出程序。
```java
public class Main4 {
    public static void main(String[] args) {
        for (int i = 0; i < 10; i++) {
            System.out.println("main");
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
            }
        }
    }
}
```

#### 线程互斥
多线程程序每个线程都是独立自由运行的, 所以它们有时候会同时操作同一个实例。这在某些情况下会引发非常严重的问题。例如最常见的例子
就是银行取钱。

假设我们有如下一段取钱伪代码

if (可用余额大于等于取款金额) {
    从可用余额扣除取出金额
}

首先会判断可用余额, 确认是否允许取款。如果允许, 则从可用余额中减去取出金额, 这样可用余额不会出现负数的情况(当然这是针对单线程程序来说)。
但是, 如果存在两个及以上的线程同时执行这段代码, 那么可用余额则有可能成为负数。

假设可用余额为100元, 取出金额为100元, 现在有线程A和线程B同时执行

![两个线程同时执行](###)

线程A和线程B同时执行, 有时线程B的处理可能会插在线程A的 "可用余额确认" 和 "从可用余额上减去取款金额" 这两个处理之间。

这种线程A和线程B之间相互竞争而引起的与预期相反的情况称为***数据竞争(data race)或叫竞态条件(race condition)***

此时需要一种机制来解决这种情况, 当一个线程在执行时另外一个线程无法操作。而Java中的synchronized可以实现线程之间的互斥。